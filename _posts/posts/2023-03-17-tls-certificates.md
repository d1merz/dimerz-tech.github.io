---
layout: post
title: "PKI, сертификаты и все все все..."
date: 2023-03-17 20:28:39 +0300
categories: posts
---

Цель написания данной статьи - агрегировать и рассмотреть бытовые случаи использования сертификатов, ключей, электронных подписей.
А самое главное - понять, как эти технологии взаимодействуют друг с другом и каждый день предоставляют нам возможность безопасно пользоваться интернетом.

Наверное каждый, кто сталкивался и пытался разобраться с такими протоколами как `https`, `tls/ssl`, `ssh`... видел на просторах интернета замечательную историю,
как [Боб и Алиса](https://ru.wikipedia.org/wiki/Алиса_и_Боб) хотят обменяться сообщениями по закрытому каналу. Поэтому повторять уже сказанное десятки раз я не буду,
мой пост больше про те аспекты, которые обычно остаются за кадром.

# Виды шифрований

Итак, мы знаем, что Бобу необходимо зашифровать сообщение Алисе, чтобы [злоумышленник](https://ru.wikipedia.org/wiki/Атака_посредника) при перехвате сообщения ничего в нем не понял.
Существует 2 вида шифрований:

<style type="text/css">
.tg  {border-collapse:collapse;border-spacing:0;}
.tg td{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  overflow:hidden;padding:10px 5px;word-break:normal;}
.tg th{border-color:black;border-style:solid;border-width:1px;font-family:Arial, sans-serif;font-size:14px;
  font-weight:normal;overflow:hidden;padding:10px 5px;word-break:normal;}
.tg .tg-d52n{background-color:#32cb00;border-color:inherit;text-align:left;vertical-align:top}
.tg .tg-0lax{text-align:left;vertical-align:top}
.tg .tg-ut5e{background-color:#c0c0c0;border-color:inherit;color:#333333;text-align:center;vertical-align:top}
.tg .tg-0pky{border-color:inherit;text-align:left;vertical-align:top}
</style>
<table class="tg">
<thead>
  <tr>
    <th class="tg-0lax"></th>
    <th class="tg-ut5e">Симметричное</th>
    <th class="tg-ut5e">Асимметричное</th>
  </tr>
</thead>
<tbody>
  <tr>
    <td class="tg-0lax">Скорость, нагрузка на CPU</td>
    <td class="tg-d52n">Быстро (короткий ключ)</td>
    <td class="tg-0pky">Медленно (длинный ключ)</td>
  </tr>
  <tr>
    <td class="tg-0lax"> Секьюрность</td>
    <td class="tg-0pky">Небезопасно (нужно обмениваться общим ключом)</td>
    <td class="tg-d52n">Безопасно (обмен происходит только открытым ключом)</td>
  </tr>
  <tr>
    <td class="tg-0lax">Алгоритмы</td>
    <td class="tg-0lax">DES, RC4, 3DES, AES, ChaCha20</td>
    <td class="tg-0lax">DSA, RSA, Diffie-Helman, ECDSA, ECDH</td>
  </tr>
</tbody>
</table>

Как видно, каждый способ имеет как плюсы, так и минусы. Однако, есть универсальное решение. И называется оно гибридным шифрованием. Мы генерируем общий (быстрый) ключ, а передаем его секьюрно
с помощью закрытого и открытого ключа. Получается, что общий ключ не подвержен перехвату (грубое утверждение), а последующее шифрование им данных происходит быстро.

Давайте сразу проверим это на практике, разыграем реальный сценарий и попробуем разные схемы шифрования и дешифрования.
### Шифрование симметричным ключом
Пусть Алисе нужно попросить Боба перевести ей деньги на банковский счет. Для этого она хочет послать сообщение: "Боб, переведи мне деньги на счет 7777 7777 7777 7777". Формируем такой файл:
```bash
echo "Боб, переведи мне деньги на счет 7777 7777 7777 7777" > message
```

Теперь нам нужно выбрать алгоритм шифрования и общий ключ. Допустим Алиса и Боб договорились, что будут использовать [AES-256](https://ru.wikipedia.org/wiki/AES_(стандарт_шифрования)#Алгоритм_генерации_раундовых_ключей) с ключом `BOBALICE`. 
Алиса шифрует сообщение с помощью ее любимой и самой распространенной утилиты [openssl](https://en.wikipedia.org/wiki/OpenSSL):
```bash
openssl aes-256-cbc -a -in message -out message.enc -pass pass:BOBALICE
```

Я намеренно выбрал самый простой способ использования openssl с наименьшим количеством настроек. Итак, рассмотрим флаги:
* `aes-256-cbc` - выбранный нами алгоритм шифрования
* `-a` означает, что нужно использовать формат выходного файла base64 (это позволит нам открыть его в текстовом редакторе)
* `-in` - наше сообщение, которое мы подаем на вход
* `-out` - base64-encoded зашифрованный файл
* `-pass pass:` - наш общий секретный ключ

Итак, посмотрим что у нас получилось:
```bash
cat message.enc
U2FsdGVkX1879r+wdwV5VqsrW40pSUmoSt9vWRCIdKRQBa+KterWsEi/Yzf2qf04
5/a+KyphdV723/l9fVEooyl34nAftACIxLzZvfWAyByfu3qhB2jLk1GbBeSMs39z
```

Теперь мы можем отправить этот файлик Бобу, зная, что кроме него никто не знает наш общий секретный ключ. Боб расшифровывает файл:

```bash
openssl aes-256-cbc -d -a -in message.enc -out message.dec -pass pass:BOBALICE
```
* `aes-256-cbc` - выбранный нами алгоритм шифрования
* `-a` означает, что нужно использовать формат входного файла base64
* `-in` - зашифрованное сообщение, которое мы подаем на вход
* `-out` - дешифрованное сообщение
* `-pass pass:` - наш общий секретный ключ

Давайте убедимся, что сообщение расшифровано успешно:
```bash
cat message.dec
Боб, переведи мне деньги на счет 7777 7777 7777 7777
```

Вот так просто мы реализовали достаточно секьюрную передачу данных между Алисой и Бобом. Тут конечно стоит сказать, что на самом деле фраза `BOBALICE` не является ключом сама по себе.
На основании ее openssl строит этот самый ключ, а сделано это для нашего с вами удобства, чтобы мы не думали о генерации 256 бит (на самом деле генерация сложно подбираемого ключа это 
тема для огромной статьи). Но суть от этого не меняется - `openssl` за нас строит такой ключ, базируясь на придуманном нами пароле.

### Гибридное шифрование
Все это время в общении Боба и Алисы отсутствовал один важный персонаж - злоумышленник Ева:
![alt text](../../images/posts/tls-certificates/alice_bob_eva.png)

Когда Алиса сообщила Бобу их общий ключ, Ева подслушала его и смогла расшифровать сообщение. Узнав об этом, Алиса и Боб решили действовать хитрее, 
применив ассиметричное шифрование для шифра их общего ключа. Для этого они решили использовать самый популярный алгоритм [RSA](https://e-nigma.ru/stat/rsa/). Для начала уже Боб генерирует пару ключей:

```bash
openssl genrsa -out bob.private 2048
openssl rsa -in bob.private -outform PEM -pubout -out bob.public
```

Здесь мы сначала генерируем 2048-битный приватный ключ (который кроме Боба знать никто не может), а затем на его основе генерируется публичный ключ (который можно показывать всем). 
`-outform PEM` указывает на хранение ключа в [PEM формате](https://firstssl.ru/faq/технические-вопросы/как-конвертировать-ssl-сертификат-в-нужный-формат). Посмотрим, что у нас получилось:

```bash
cat bob.private
-----BEGIN RSA PRIVATE KEY-----
MIIEowIBAAKCAQEAu0LVuZC0Kld9izrNX6H++gFzbc6b9j3cefnZqsqmwuHcgIuO
o0TNxcf9nfRmETMFG1WzXbSXgSh/cjOAkNdYDc1aC3sGTrW8aP6KVN8q6hzryyY4
rmNFGpkt+fJLIYIqQtkt9+A1l01bpRhphfMVFodAvRnBbDyZ0y2XiqLkmPdQlG+s
f+UtOEb5QYdKrzl0bSIVWLoBqUnvn6Xy8R+zUzVYSwHqMenKH1wG72xnnZavb2HW
qO2+AJXomdrANBkCILfqyM7J+20lIeAOUvc1ljtmb0t7AVo0wNlic1vDiJhomJ7m
lRBi3x+mOjg19LIKX8+aPWal1BCyT2t8KFh0lwIDAQABAoIBAC6cl0iGbWIwvu4+
J8rLLwWaANpvWED16wBtobGymcneoJ1an5miUboOauG7aQCU+4tvTKNhhWi/5OFP
Uow7Hg7pc6Vx7QMAl7Jm0ZYIqsz1f/fkPq2hxhy1zkzt86eWl+Bl4NxXcd+EgPBa
YEHYXQJrjkDDvXKsrvly2srGezJbyDAhVvi6dGl30IYRSroWXrSgzrVsZKW45yl2
T/o1OBhwKxsiY22Cj7Zl30Z7mrneudlBEQKw3bgLmhIBXxluS0UMcTntLfJQuZky
5NcgJN4pNeFeISkFDs6/o5qB2j7E9P+NMdFIqQYYNu4LwZvGqWNjIoL8fRQek7S0
LxXhW+kCgYEA3W7gqD4fMsM6bOec9oRbaiHBprjvW9i4ESuBErzudcqU2NeMP7Le
8buWi8Ii4CzJvnVIsGi5uXPYobklcemR8R2nxK7JzaWX+LOa0ENGHcuDJ33tMaW4
ejLjIwbkprRddy2uAP9h13b0d78PI+J7O1ufxYaTBx2S0HPmCVPDlSsCgYEA2H5X
ZiYZkqIttSurw5TzVsAz+/eruzvetCfCPQUUMBcVew1ebnjcB5BEgWbFyHMFmPSH
T2bTW63Anh8Qt0fKdPiVrSJYmZpSd8YoxlLHlMQkowYVOjI26L35ud+5JxUeHl7G
oTfsnwruy2Qw2BO/bexHNw9x7hQbHPv96U/DwEUCgYEAqlb0LZh0SYmTdVmLDrxs
0i0bmlSjlSUXG+Y6iZ6bVjO74z+VXR8NkCm9Os/iIk9x9rikbUhyru4mFOqnmoSS
R0iH2a6YAUHEsYYArvtBggQfZY7im5GfYymoPza7SF5xlA+ozo2mx6hzkXaBgBpm
sBfgxYOrsQqX+RFfQYeVajcCgYBL5SbAkbS/WgmKDNA/VXVlQSY4O+BBWEC/iXyn
paMpJL6MD+i987K3GBVcA+psVh5tO7Q/2r1X03bGN//FMO7ByO+37WWAG8Czao2a
0SRUe9qYKCbC6x2ixA7K4apoEBgp73HUzOUv8EY8mVgiN/IRGBbzL3/yRawnohOm
eicWvQKBgEKQ4XPW3mmyvTVf9h72c8CygTq3mZiBhlczxTDvZdf37EznI1E0LRGH
OiwjKO4NOy14TlwUtKijWczJtVJRPqoOYiTMVUB4OkKiYVfvRF7u7IS3r4WeuNcY
Ei/VuLLS8nAKpITuQ5FJOaASFuDbIzZsqZ7fl26YxRIh/uidEJML
-----END RSA PRIVATE KEY-----
```
Это тот самый секретный ключ, доступ к которому злоумышленник может получить, разве что при физическом доступе к машине Боба, в рамках нашей задаче будем считать, что это невозможно.

```bash
cat bob.public
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu0LVuZC0Kld9izrNX6H+
+gFzbc6b9j3cefnZqsqmwuHcgIuOo0TNxcf9nfRmETMFG1WzXbSXgSh/cjOAkNdY
Dc1aC3sGTrW8aP6KVN8q6hzryyY4rmNFGpkt+fJLIYIqQtkt9+A1l01bpRhphfMV
FodAvRnBbDyZ0y2XiqLkmPdQlG+sf+UtOEb5QYdKrzl0bSIVWLoBqUnvn6Xy8R+z
UzVYSwHqMenKH1wG72xnnZavb2HWqO2+AJXomdrANBkCILfqyM7J+20lIeAOUvc1
ljtmb0t7AVo0wNlic1vDiJhomJ7mlRBi3x+mOjg19LIKX8+aPWal1BCyT2t8KFh0
lwIDAQAB
-----END PUBLIC KEY-----
```
А вот это уже открытый для всех желающих публичный ключ Боба. Теперь Боб спокойно пересылает его Алисе. И даже если Ева перехватит этот ключ, толку от него никакого.
Алиса же на своей стороне шифрует этим ключом их общий пароль BOBALICE:
```bash
echo "BOBALICE" > password
openssl rsautl -encrypt -inkey bob.public -pubin -in password -out password.enc
```
* `rsautl` - команда openssl для шифровки/дешифровки
* `-encrypt` говорит о том, что необходимо зашифровать файл
* `-inkey` - публичный ключ Боба
* `-pubin -in` - файл для шифрования
* `-out` - зашифрованный файл с общим паролем

Теперь Алиса спокойно отправляет по открытой сети файл password.enc и даже если Ева перехватит это сообщение, то расшифровать она его не сможет, потому что закрытый ключ находится на машине Боба.
Боб же, получив сообщение от Алисы, расшифровывает его с помощью своего приватного ключа:
```bash
openssl rsautl -decrypt -inkey bob.private -in password.enc
BOBALICE
```
А дальше задача общения между Бобом и Алисой сводится к уже решенной симметричным шифрованием. На самом деле, Алиса могла бы сгенерировать свою пару ключей и они могли бы общаться
посредством ассиметричного шифра, но как мы уже сказали ранее это более процессорно-затратно. Получается, что для Евы потерян смысл слушать канал между Бобом и Алисой и кажется задача
безопасной передачи данных решена...

Но давайте рассмотрим случай, когда Ева заранее узнает о планах Боба и Алисы пообщаться. В таком случае, Ева может написать Бобу первой от лица Алисы и передать ему свой открытый ключ для шифрования.
Для решения этой проблемы была придумана электронная цифровая подпись.

## ЭЦП
Электронная подпись появилась благодаря внезапному свойству ассиметричных ключей быть симметричными. То есть то, <ins> что шифрует открытый ключ, может быть расшифровано закрытым, 
а то что шифрует закрытый ключ, может быть расшифровано открытым </ins>. Итак, рассмотрим новый сценарий:

Ева пишет Бобу сообщение
```bash
# Устройство Евы:
echo "Боб, это Алиса, я потеряла твой публичный ключ, отправь мне его еще раз"
```

Далее Боб присылает свой публичный ключ и Ева шлет ему следующее сообщение:
```bash
# Устройство Евы:
echo "Боб, переведи мне деньги на счет 8888 8888 8888 8888"
```

И в это же время Алиса (у которой уже есть публичный ключ Боба) пишет такое же сообщение:
```bash
# Устройство Алисы:
echo "Боб, переведи мне деньги на счет 7777 7777 7777 7777"
```

Как Бобу понять, кто является злоумышленником ? Оказывается, для этого необходимо, чтобы Боб знал также публичный ключ Алисы. Давайте потребуем 2 условия:
* Теперь каждое сообщение (включая первое) должно быть зашифровано
* Боб уже знает публичный ключ Алисы и Алиса знает публичный ключ Боба (как безопасно осуществить их передачу будет рассказано позже)

Еще немного теории и мы доберемся до разоблачения Евы.

Мы уже знаем, что шифровать сообщение ассиметричными ключами процесс медленный, как мы можем обойти это ограничение? Зашифровать хеш этого сообщения! И именно это и называется
электронной цифровой подписью. На бумаге это будет работать так:
1. Алиса пишет Бобу сообщение, считает от него хеш, шифрует хеш своим приватным ключом, прикрепляет зашифрованный хеш к сообщению и все это вместе еще можно зашифровать симметричным ключом (если такой имеется)
2. Ева делает абсолютно то же самое со своими ключами
3. Боб получает 2 сообщения (от Евы и Алисы) и 2 их зашифрованных хеша
4. Боб, <ins>зная только публичный ключ Алисы</ins>, поочереди пробует расшифровать оба хеша и <ins>только в одном случае</ins> ему это удается

Но у ЭЦП есть еще одно полезное свойство - проверка целостности переданных данных. Успешно расшифровав хеш сообщения Алисы, Боб может посчитать свой хеш от этого же сообщения 
и при совпадении убедиться, что сообщение доставлено корректно без изменений. Посмотрим как это выглядело бы на практике:

```bash
# Алиса генерирует пару ключей
openssl genrsa -out alice.private 2048
openssl rsa -in alice.private -outform PEM -pubout -out alice.public
```

```bash
# Ева генерирует пару ключей
openssl genrsa -out eva.private 2048
openssl rsa -in eva.private -outform PEM -pubout -out eva.public
```

Боб как-то (опять же повторюсь, позже мы рассмотрим этот вопрос) узнает о публичном ключе Алисы. Далее:

```bash
# Алиса подписывает сообщение своим приватным ключом:
echo "Боб, переведи мне деньги на счет 7777 7777 7777 7777" > alice_message
openssl dgst -sha256 -sign alice.private -out alice_message.sign alice_message
```

```bash
# Ева подписывает сообщение своим приватным ключом:
echo "Боб, переведи мне деньги на счет 8888 8888 8888 8888" > eva_message
openssl dgst -sha256 -sign eva.private -out eva_message.sign eva_message
```

* `dgst` - утилита библиотеки openssl для создания ЭЦП
* `-sha256` - алгоритм хеширования
* `-sign` - приватный ключ
* `-out` - получившаяся подпись

Дальше мы можем зашифровать сообщения и хеш симметричным ключом, но в целях упрощения будем считать, что они передаются в открытом виде.
Боб получает 2 сообщения и 2 хеша к ним:

```bash
# Боб проверяет первое сообщение и хеш публичным ключом Алисы
openssl dgst -sha256 -verify alice.public -signature alice_message.sign alice_message
Verified OK
```

```bash
# Боб проверяет второе сообщение и хеш публичным ключом Алисы
openssl dgst -sha256 -verify alice.public -signature eva_message.sign eva_message
Verification Failure
```

Как видим, таким нехитрым образом Боб смог отличить оригинальное сообщение от фэйка.

### Мини итог

1. Мы узнали, что для безопасной передачи данных необходимо и достаточно наличие публичных ключей друг друга у обоих участников процесса
2. Для аутентификации (то есть подтверждения личности) используется подпись приватным ключом
3. Для быстрой и безопасной передачи данных используется шифрование симметричным ключом
4. Для обмена общим симметричным ключом используется шифрование публичным ключом

Теперь осталось решить последний вопрос, как же все таки безопасно обменяться публичными ключами в самом начале диалога?

## Сертификаты, CA, PKI

Уходя чуть в сторону от темы безопасности, давайте подумаем, а как обеспечивается идентификация личности в реальной жизни? Почему нельзя прийти в банк и снять деньги с чужого
счета, просто представившись другим человеком? Потому что у всех нас есть паспорт, выданный доверенным лицом - Федеральной миграционной службой. Это очень важный момент, что
все граждане доверяют этой службе и считают ее гарантом того, что паспорт действительно принадлежит конкретному человеку. Теперь представим, что в интернете тоже есть ряд таких служб.
И он действительно есть, такие службы называются удостоверяющими центрами ([CA](https://en.wikipedia.org/wiki/Certificate_authority)). Всего 6 самый популярных центров действуют сейчас на весь интернет.
И выступают гарантом того, что когда вы пишете в поиске `google.com` вы действительно идете на оригинальный, а не фишинговый сайт. Ну раз у нас есть аналог ФМС, значит должен быть и аналог
паспорта. Этот аналог и называется сертификат. Самый простой способ узнать о нем подробно - это открыть браузер, зайти на какой-нибудь сайт и нажать `посмотреть сертификат сайта`:

![alt text](../../images/posts/tls-certificates/cert1.png)

Я лишь скажу о самых важных его составляющих:
1. Ваш публичный ключ
2. Срок действия сертификата
3. Кем выдан сертификат

Ну все как в наших документах. А теперь самое главное. Паспорт можно напечатать и на принтере, только вот действительным он станет только тогда, когда в нем поставят печать.
Так и с сертификатом. Сертификат валиден, только если какой-то из удостоверяющих центров подписал его своей ЭЦП. 
Для этого пользователь должен сделать специальный запрос на подпись [CSR](https://en.wikipedia.org/wiki/Certificate_signing_request).
И вот все вышеперечисленное вместе называется [PKI](https://ru.wikipedia.org/wiki/Инфраструктура_открытых_ключей).
![alt text](../../images/posts/tls-certificates/certs_exchange.png)

### Полный сценарий
Давайте создадим свой личный PKI и передадим наконец сообщение по безопасной схеме.

Для начала создадим локальную имитацию удостоверяющего центра (в реальности мы конечно бы пользовались каким-то внешним сервисом). Для этого:
```bash
# Шаг 0. Генерируем закрытый ключ нашего CA
openssl genrsa -des3 -out CA.key 2048
# Шаг 1. Генерируем самоподписанный сертификат нашего CA
openssl req -x509 -new -key CA.key -sha256 -days 1825 -out CA.pem
-----
Country Name (2 letter code) []:RU
State or Province Name (full name) []:MOSCOW
Locality Name (eg, city) []:
Organization Name (eg, company) []:ORG
Organizational Unit Name (eg, section) []:UNIT
Common Name (eg, fully qualified host name) []:
Email Address []:

```

Здесь я заполнил для примера часть данных о нашей организации. Разберем, что мы сейчас сделали, во-первых, по флагам:
* `req` - команда которая создает и обрабатывает CSR. То есть мы за одно действие создали запрос сертификата и подписали сертификат, 
используя собственный закрытый ключ. Поэтому такой сертификат называется самоподписанным.
* `-x509` - формат выпущенного сертификата (это опция сообщает что нужно сгенерировать именно сертификат, а не CSR)
* `-new` - создать новый запрос на сертификат
* `CA.key` - наш закрытый ключ
* `-sha256` - алгоритм хеширования (как мы помним используется для ЭЦП)
* `-days` - сколько дней будет валиден наш сертификат

Давайте посмотрим на содержимое сертификата:
![alt text](../../images/posts/tls-certificates/cert2.png)

Следующий шаг - сгенерировать сертификаты Боба, Алисы и Евы и запросить у CA их подпись, то есть сделать CSR. На самом деле сам сертификат создается удостоверяющим центром. 
Сейчас мы сгенерируем CSR с необходимыми для генерации сертификата данными.
```bash
openssl req -new -key bob.private -out bob.csr
openssl req -new -key alice.private -out alice.csr
openssl req -new -key eva.private -out eva.csr
```

Здесь мы так же используем команду `req`, однако напрямую не говорим, о том, что нужно сгенерировать сертификат, поэтому она генерирует лишь запрос на его подпись.
Здесь есть тонкий и не совсем прозрачный момент, почему мы указываем приватный ключ, если его нельзя никому передавать? 
Все дело в том, что в запросе на подпись сертификата содержится публичный ключ организации и информация о ней (в нашем случае о частных лицах).
И если выполнить команду:
```bash
openssl rsa -in bob.private -pubout
writing RSA key
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu0LVuZC0Kld9izrNX6H+
+gFzbc6b9j3cefnZqsqmwuHcgIuOo0TNxcf9nfRmETMFG1WzXbSXgSh/cjOAkNdY
Dc1aC3sGTrW8aP6KVN8q6hzryyY4rmNFGpkt+fJLIYIqQtkt9+A1l01bpRhphfMV
FodAvRnBbDyZ0y2XiqLkmPdQlG+sf+UtOEb5QYdKrzl0bSIVWLoBqUnvn6Xy8R+z
UzVYSwHqMenKH1wG72xnnZavb2HWqO2+AJXomdrANBkCILfqyM7J+20lIeAOUvc1
ljtmb0t7AVo0wNlic1vDiJhomJ7mlRBi3x+mOjg19LIKX8+aPWal1BCyT2t8KFh0
lwIDAQAB
-----END PUBLIC KEY-----
```
мы увидим, что внутри приватного ключа лежит и публичный, именно так он оказывается внутри CSR (а самого приватного ключа, конечно же там нет). Можем в этом убедиться:
```bash
openssl req -in bob.csr -pubkey
-----BEGIN PUBLIC KEY-----
MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAu0LVuZC0Kld9izrNX6H+
+gFzbc6b9j3cefnZqsqmwuHcgIuOo0TNxcf9nfRmETMFG1WzXbSXgSh/cjOAkNdY
Dc1aC3sGTrW8aP6KVN8q6hzryyY4rmNFGpkt+fJLIYIqQtkt9+A1l01bpRhphfMV
FodAvRnBbDyZ0y2XiqLkmPdQlG+sf+UtOEb5QYdKrzl0bSIVWLoBqUnvn6Xy8R+z
UzVYSwHqMenKH1wG72xnnZavb2HWqO2+AJXomdrANBkCILfqyM7J+20lIeAOUvc1
ljtmb0t7AVo0wNlic1vDiJhomJ7mlRBi3x+mOjg19LIKX8+aPWal1BCyT2t8KFh0
lwIDAQAB
-----END PUBLIC KEY-----
```

После того как CA получил запросы на подпись сертификатов, он может запросить дополнительную информацию, для проверки их личности (например, доверенная ли это организация и т.д.).
CA знает, о том, что Ева является злоумышленником и не подписывает ее сертификат. Для остальных же генерируем его:

```bash
# Удостоверяющий центр выдает сертификат Бобу:
openssl x509 -req -in bob.csr -CA CA.pem -CAkey CA.key -CAcreateserial -out bob.crt -days 500 -sha256
# Удостоверяющий центр выдает сертификат Алисе:
openssl x509 -req -in alice.csr -CA CA.pem -CAkey CA.key -CAcreateserial -out alice.crt -days 500 -sha256
```

* `x509` - команда для создание сертификата в формате x509
* `-req` - говорит о том, что на вход будет подан CSR
* `-in` - CSR
* `-CA` - сертификат удостоверяющего центра
* `-CAkey` - закрытый ключ удостоверяющего центра
* `-CAcreateserial` - создает файлик, в котором храниться порядковый (уникальный) номер сертификата
* `-out` - получившийся подписанный сертификат

Теперь, Алиса будет отправлять Бобу не открытый ключ в чистом виде, а свой сертификат. Боб, сможет проверить его, так как сертификат подписан закрытым ключом CA, которому доверяют все.
Для этого ему нужно выполнить команду:

```bash
openssl verify -CAfile CA.pem alice.crt
alice.crt: OK
```

Ева же не может отправить свой сертификат Бобу. Она может сделать свой CA, подписать им сертификат, но ее удостоверяющий центр нарушит свое главное свойство - ему не будут доверять.

Таким образом проблема аутентификации разрешена.

## Итог
Схема безопасного обмена данными по открытой сети:
1. Необходим доверенный удостоверяющий центр, имеющий свой закрытый ключ и сертификат
2. Участники обмена делают запрос на подпись (CSR) в этот CA
3. CA генерирует для каждого из участников сертификат, подписанный своим закрытым ключом
4. Перед началом общения участники передают друг другу публичные ключи через подписанные CA сертификаты
5. Проверка подписи сертификата осуществляется открытым ключом из сертификата CA
6. После успешного подтверждения личности один из участников генерирует общий ключ, шифруя его открытым ключом другого участника
7. Зашифрованный открытым ключом общий секрет расшифровывается закрытым ключом, находящимся у второго участника
8. Далее каждое сообщение сессии шифруется общим открытым ключом для быстрой передачи данных

# Примечание
Оставлю здесь полезные ссылки для более подробного изучения данной темы. 

* [Diffie–Hellman key exchange](https://ru.wikipedia.org/wiki/Протокол_Диффи_—_Хеллмана) (или как еще можно получить общий секрет)
* [YouTube канал](https://www.youtube.com/@PracticalNetworking), с кучей коротких и понятных видео по тематике сетей, протоколов и безопасности
* [OpenSSL cheatsheet](https://gist.github.com/mohanpedala/468cf9cef473a8d7610320cff730cdd1)
* [TLS connection](https://tls12.xargs.org) (классный и подробный разбор)
