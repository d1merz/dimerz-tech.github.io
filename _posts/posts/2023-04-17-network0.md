---
layout: post
title: "Сеть. Часть 0. Пакеты, интерфейсы, iptables"
date: 2023-04-17 20:28:39 +0300
categories: [posts, network]
---

Всем привет! Давно хотел разобрать(ся) и собрать полезную информацию по сетевым настройкам linux. Тема очень обширная,
поэтому здесь я оставлю информацию только по самым актуальным в первую очередь для себя вопросам.

# Устройство сетевого пакета и OSI
Сетевой пакет - это матрешка, луковица или капуста, которая отражает суть модели [OSI](https://ru.wikipedia.org/wiki/Сетевая_модель_OSI) в своих слоях.
В пакетах носят полезные вещи, так и у сетевых пакетов есть полезная нагрузка (Payload), например, это биты сообщения, которое вы хотите отправить.
Эти биты инкапсулируются на каждом уровне модели и к ним добавляется все больше и больше слоев (заголовков), например адрес доставки пакета, версии поддерживаемых протоколов,
версии алгоритмов шифрования и тд. А когда такой пакет доходит до цели, он начинает в обратном порядке избавляться от слоев информации, в конечном итоге доставив
только те самые биты оригинального сообщения.

# Сетевые интерфейсы
Интерфейсы бывают двух типов: физические и виртуальные. Интерфейс - это вообще говоря конечная точка сетевого пакета, дальше это устройство передает данные в оперативную память
и оттуда уже к пользовательскому приложению. В одном компьютере может быть несколько интерфейсов (VPN-туннель, Wi-Fi адаптер и проводной ethernet), 
и с точки зрения сетевых взаимодействий их можно рассматривать как отдельные сетевые элементы. В ядре заложена специальная логика, по которой можно перекидывать пакеты с
одних интерфейсов на другие. Посмотреть список доступных интерфейсов можно командами:
```bash
ip link show
1: lo: <LOOPBACK,UP,LOWER_UP> mtu 65536 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/loopback 00:00:00:00:00:00 brd 00:00:00:00:00:00
2: eth0: <BROADCAST,MULTICAST,UP,LOWER_UP> mtu 1500 qdisc mq state UP mode DEFAULT group default qlen 1000
    link/ether 00:15:5d:0d:f7:0c brd ff:ff:ff:ff:ff:ff
4: docker0: <NO-CARRIER,BROADCAST,MULTICAST,UP> mtu 1500 qdisc noqueue state DOWN mode DEFAULT group default 
    link/ether 02:42:b2:5a:60:8b brd ff:ff:ff:ff:ff:ff
5: wg0: <POINTOPOINT,NOARP,UP,LOWER_UP> mtu 1420 qdisc noqueue state UNKNOWN mode DEFAULT group default qlen 1000
    link/none 
    
# Или
ifconfig
docker0: flags=4099<UP,BROADCAST,MULTICAST>  mtu 1500
        inet 172.17.0.1  netmask 255.255.0.0  broadcast 172.17.255.255
        ether 02:42:b2:5a:60:8b  txqueuelen 0  (Ethernet)
        RX packets 0  bytes 0 (0.0 B)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 0  bytes 0 (0.0 B)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

eth0: flags=4163<UP,BROADCAST,RUNNING,MULTICAST>  mtu 1500
        inet *.*.*.*  netmask 255.255.255.0  broadcast 0.0.0.0
        inet6 fe80::215:5dff:fe0d:f70c  prefixlen 64  scopeid 0x20<link>
        ether 00:15:5d:0d:f7:0c  txqueuelen 1000  (Ethernet)
        RX packets 1371144428  bytes 1302245454054 (1.3 TB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 1370637734  bytes 1338942966500 (1.3 TB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

lo: flags=73<UP,LOOPBACK,RUNNING>  mtu 65536
        inet 127.0.0.1  netmask 255.0.0.0
        inet6 ::1  prefixlen 128  scopeid 0x10<host>
        loop  txqueuelen 1000  (Local Loopback)
        RX packets 15094627  bytes 1916500791 (1.9 GB)
        RX errors 0  dropped 0  overruns 0  frame 0
        TX packets 15094627  bytes 1916500791 (1.9 GB)
        TX errors 0  dropped 0 overruns 0  carrier 0  collisions 0

wg0: flags=209<UP,POINTOPOINT,RUNNING,NOARP>  mtu 1420
        inet 10.0.0.1  netmask 255.255.255.255  destination 10.0.0.1
        unspec 00-00-00-00-00-00-00-00-00-00-00-00-00-00-00-00  txqueuelen 1000  (UNSPEC)
        RX packets 337737322  bytes 105907073836 (105.9 GB)
        RX errors 193337  dropped 0  overruns 0  frame 193337
        TX packets 1003846746  bytes 1194126328564 (1.1 TB)
        TX errors 11086  dropped 242971 overruns 0  carrier 0  collisions 0
```

# Netfilter (aka Linux firewall)
Netfilter это утилита из ядра Linux, которая позволяет разрешать/запрещать/изменять пакеты, которые либо мы получили, либо отправили.
Так как это модуль ядра, у него есть популярный фронтенд, через который мы с вами можем с этим модулем взаимодействовать - инструмент iptables.
Далее мы на практике рассмотрим несколько самых популярных правил, а пока я приведу схему (на мой взгляд самую понятную из всех, что я видел) работы netfilter:
![alt text](https://cloud.githubusercontent.com/assets/1711674/8742363/87fad710-2c32-11e5-8896-7adf1a4cf164.png)
А вот [тут](https://www.youtube.com/watch?v=Q0EC8kJlB64) самое классное видео по настройке
Здесь отражен путь, который проходит сетевой пакет. Снизу вверх отображены таблицы, а слева направо цепочки в этих таблицах.
Логика такая:
0. Все начинается с цепочки **PREROUTING**. Эта цепочка отвечает за самые предварительные правила роутинга пакета (что видно из названия). Рассмотрим их подробнее.
1. Пакет пришел на наше устройство. Он попадает в таблицу хранения состояний соединений **conntrack** (это специфичная таблица поэтому не будем на ней задерживаться). Скажу лишь то, что раньше (когда-то) ее не было, и все соединения были
stateless (то есть не было состояние единого потока, "сессии", каждый пакет рассматривался отдельно от остальных). Это привело к уязвимостям (например, нельзя было сказать, что 
Ack пакет легитимен и это не попытка просканировать порты).
2. Затем пакет попадает в таблицу **mangle**. Эта таблица отвечает за изменение характеристик пакета, вот например нам нужно поменять его время жизни (TTL). 
3. Из mangle пакет идет в таблицу **nat**, где нам доступна возможность изменить ip заголовок пакета. На картинке (внизу) указано, что на этом этапе доступно свойство DNAT (Destination NAT).
То есть мы можем поменять целевой адрес пакета. Ну например, сделать так, чтобы пакеты, которые попали к нам, предназначались для другой сети и не обрабатывались нашим устройством
4. И последняя таблица, она же самая популярная - **filter** в этой цепочке НЕ используется (видно, что кружка на схеме нет), поэтому обсудим ее далее.
5. Теперь, перейдем к следующему этапу. Здесь, с помощью таблицы роутинга, о которой мы поговорим позже, решается предназначен ли пакет для нашего сетевого интерфейса
или его нужно передать другому устройству.
6. Если пакет "наш" (local), то он попадает в цепочку **INPUT**. Иначе, нам нужно отправить его в сеть дальше и он попадает в цепочку **FORWARD**.
7. Как видно из схемы для обоих цепочек действуют только таблицы **MANGLE** и **FILTER**. Здесь мы решаем отбрасывать пакет сразу или дать ему шанс пройти по цепочкам дальше. К примеру, можно заблокировать соединение
с определенного ip адреса. Или же наоборот - заблокировать исходящее соединение.
8. Далее наш пакет приходит либо в сокет (доходит до конечного приложения) либо попадает в цепочку **OUTPUT** (если он был ранее предназначен для дальнейшей транспортировки). 
Здесь применяются все 4 таблицы. Также для этой цепочки предназначаются пакеты, которые мы сами генерируем и отправляем с нашего устройства.
9. Ну и наконец, непосредственно перед отправкой пакета дальше в сеть используется цепочка **POSTROUTING**, где мы можем напоследок поменять характеристики пакета.

Краткая выжимка из этого всего: есть цепочки (пути, по которым пойдет пакет). И есть таблицы (правила, что нужно сделать с пакетом на данном этапе). Например, если пакет пришел
к приложению на нашем хосте (скажем Nginx), значит она пойдет по цепочкам **PREROUTING -> INPUT**. А ответ от этого приложения пойдет по цепочкам **OUTPUT -> POSTROUTING**.
А еще можно в этих цепочках применить таблицы, и поменять пакет. Это все.

## iptables
Теперь рассмотрим как нам настраивать данные правила. В самом простом варианте вызов iptables выглядит так:
```bash
iptables таблица цепочка правило действие
```
Вот например, чтобы ограничить трафик до нашего устройства с определенного ip адреса используется такая команда:
```bash
sudo iptables -A INPUT -s 203.0.113.51 -j DROP
```
Если идти по схеме, то здесь написано добавь `-A` в цепочку `INPUT` таблицы `FILTER` (не указана, используется по умолчанию) 
правило `-s 203.0.113.51` (все пакеты с таким source ip адресом) для которого будет применено действие `-j DROP` - отклонять все такие пакеты

Я заказал себе 2 сервера с внешними статическими ip адресами: `195.84.182.1` и `193.108.113.219`
Давайте попробуем ограничить доступ с первого сервера на второй, для этого сначала убеждаемся, что соединение имеется:

```bash
filintech@194:~$ ping -I eth0 193.108.113.219
PING 193.108.113.219 (193.108.113.219) from 195.84.182.1 eth0: 56(84) bytes of data.
64 bytes from 193.108.113.219: icmp_seq=1 ttl=59 time=39.3 ms
64 bytes from 193.108.113.219: icmp_seq=2 ttl=59 time=40.5 ms
64 bytes from 193.108.113.219: icmp_seq=3 ttl=59 time=40.8 ms
64 bytes from 193.108.113.219: icmp_seq=4 ttl=59 time=39.7 ms
```

Теперь на втором сервере я применяю правило:
```bash
filintech@193:~$ sudo iptables -A INPUT -s 195.84.182.1 -j DROP
filintech@193:~$ sudo iptables -L INPUT
Chain INPUT (policy ACCEPT)
target     prot opt source               destination         
DROP       all  --  194.87.186.2         anywhere
```

С помощью ключа `-L` можно смотреть цепочки правил, как видим оно применилось. Пробуем еще раз проверить соединение с первого сервера:

```bash
filintech@194:~$ ping -I eth0 193.108.113.219
PING 193.108.113.219 (193.108.113.219) from 195.84.182.1 eth0: 56(84) bytes of data.
--- 193.108.113.219 ping statistics ---
5 packets transmitted, 0 received, 100% packet loss, time 4075ms
```

Чтобы удалить правило, используется ключ `-D`:
```bash
filintech@193:~$ sudo iptables -D INPUT -s 195.84.182.1 -j DROP
```

### route
Очень часто происходит путаница между фаерволом и таблицей маршрутизации linux. Netfilter отвечает на вопрос что делать с данным пакетом? Запретить? Разрешить? Изменить?
Routing table же отвечает на вопрос - для кого предназначается пакет? Какой сетевой интерфейс за него ответственен? Для того, чтобы посмотреть таблицу роутинга можно использовать команду
```bash
filintech@194:~$ ip route show
default via 195.84.182.1 dev eth0 
10.0.0.0/16 dev wg0 scope link 
10.0.0.2 dev wg0 scope link 
172.17.0.0/16 dev docker0 proto kernel scope link src 172.17.0.1 linkdown 
195.84.182.0/24 dev eth0 proto kernel scope link src 195.84.182.2 
```
Опять же, в интернете куча статей по данной теме, поэтому приложу ссылку. Данная таблица используется для определения маршрута пакета. Маршрут - это интерфейс, которым пакет
будет обработан. Например, если вы отправляете пакет в интернет, то вам необходимо передать его на тот интерфейс, через который он попадет в дальнейшую сеть. В моем примере
это дефолтный маршрут. via означает, что для доступа в сеть используется шлюз (gateway). А с этим шлюзом в свою очередь связан интерфейс eth0. Более наглядно можно посмотреть с помощью
```bash
filintech@194:~$ route -n
Kernel IP routing table
Destination     Gateway         Genmask         Flags Metric Ref    Use Iface
0.0.0.0         195.84.182.1    0.0.0.0         UG    0      0        0 eth0
10.0.0.0        0.0.0.0         255.255.0.0     U     0      0        0 wg0
10.0.0.2        0.0.0.0         255.255.255.255 UH    0      0        0 wg0
172.17.0.0      0.0.0.0         255.255.0.0     U     0      0        0 docker0
195.84.182.0    0.0.0.0         255.255.255.0   U     0      0        0 eth0
```

Здесь видно, что дефолтный маршрут описывается адресом 0.0.0.0 и маской 0.0.0.0, то есть это все возможные адреса. Когда мы запускаем, например, docker, можно увидеть, что
он создает виртуальный интерфейс docker0. Также создает свою подсеть, и если пакет приходит на адрес 172.17.\*.\* то передается именно на интерфейс докера.
Более подробно аспекты обработки пакетов будут рассмотрены в дальнейших частях на конкретных примерах.

## Ссылки
https://habr.com/ru/articles/493880/ - топовая статья про самые кишки анализаторов пакетов
https://habr.com/ru/companies/ruvds/articles/457386/ - про туннели
https://www.youtube.com/watch?v=Q0EC8kJlB64 - классное видео по настройке iptables  

